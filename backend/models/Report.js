const mongoose = require('mongoose');

const reportSchema = new mongoose.Schema({
  // Report Basic Information
  title: {
    type: String,
    required: [true, 'Report title is required'],
    trim: true,
    maxlength: [200, 'Title cannot exceed 200 characters']
  },
  description: {
    type: String,
    maxlength: [1000, 'Description cannot exceed 1000 characters']
  },
  
  // Report Type and Purpose
  type: {
    type: String,
    required: [true, 'Report type is required'],
    enum: [
      'student_portfolio',
      'department_summary',
      'accreditation_report',
      'activity_analysis',
      'performance_report',
      'compliance_report',
      'custom_report'
    ]
  },
  purpose: {
    type: String,
    enum: ['NAAC', 'NIRF', 'AICTE', 'internal', 'external', 'research'],
    required: [true, 'Report purpose is required']
  },
  
  // Report Scope
  scope: {
    students: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    }],
    departments: [String],
    academicYear: {
      type: String,
      required: [true, 'Academic year is required']
    },
    semester: {
      type: Number,
      min: 1,
      max: 8
    },
    dateRange: {
      startDate: {
        type: Date,
        required: [true, 'Start date is required']
      },
      endDate: {
        type: Date,
        required: [true, 'End date is required']
      }
    }
  },
  
  // Report Generation Details
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Generated by user is required']
  },
  generationDate: {
    type: Date,
    default: Date.now
  },
  
  // Report Content and Filters
  filters: {
    activityCategories: [{
      type: String,
      enum: [
        'academic', 'research', 'conference', 'workshop', 'certification',
        'internship', 'project', 'competition', 'volunteering',
        'extracurricular', 'leadership', 'publication', 'patent', 'award'
      ]
    }],
    minCredits: {
      type: Number,
      min: 0,
      default: 0
    },
    approvalStatus: {
      type: String,
      enum: ['all', 'approved', 'pending', 'rejected'],
      default: 'approved'
    },
    includeGrades: {
      type: Boolean,
      default: true
    },
    includeDocuments: {
      type: Boolean,
      default: false
    }
  },
  
  // Report Statistics
  statistics: {
    totalStudents: {
      type: Number,
      default: 0
    },
    totalActivities: {
      type: Number,
      default: 0
    },
    totalCredits: {
      type: Number,
      default: 0
    },
    averageActivitiesPerStudent: {
      type: Number,
      default: 0
    },
    categoryBreakdown: [{
      category: String,
      count: Number,
      percentage: Number
    }],
    departmentBreakdown: [{
      department: String,
      studentCount: Number,
      activityCount: Number,
      averageCGPA: Number
    }]
  },
  
  // File Information
  file: {
    filename: String,
    originalName: String,
    url: String,
    public_id: String,
    fileType: {
      type: String,
      enum: ['pdf', 'excel', 'csv', 'json'],
      default: 'pdf'
    },
    size: Number, // in bytes
    generatedAt: {
      type: Date,
      default: Date.now
    }
  },
  
  // Report Status
  status: {
    type: String,
    enum: ['generating', 'completed', 'failed', 'expired'],
    default: 'generating'
  },
  
  // Access Control
  isPublic: {
    type: Boolean,
    default: false
  },
  accessLevel: {
    type: String,
    enum: ['private', 'department', 'faculty', 'public'],
    default: 'private'
  },
  sharedWith: [{
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    permissions: {
      type: String,
      enum: ['view', 'download', 'edit'],
      default: 'view'
    },
    sharedAt: {
      type: Date,
      default: Date.now
    }
  }],
  
  // Report Configuration
  template: {
    type: String,
    enum: ['standard', 'detailed', 'summary', 'accreditation', 'custom'],
    default: 'standard'
  },
  format: {
    includeCharts: {
      type: Boolean,
      default: true
    },
    includeImages: {
      type: Boolean,
      default: false
    },
    pageOrientation: {
      type: String,
      enum: ['portrait', 'landscape'],
      default: 'portrait'
    },
    colorScheme: {
      type: String,
      enum: ['default', 'monochrome', 'institutional'],
      default: 'default'
    }
  },
  
  // Expiry and Cleanup
  expiresAt: {
    type: Date,
    default: function() {
      // Reports expire after 90 days by default
      return new Date(Date.now() + 90 * 24 * 60 * 60 * 1000);
    }
  },
  
  // Metadata
  metadata: {
    generationTime: Number, // in milliseconds
    fileSize: Number, // in bytes
    pageCount: Number,
    version: {
      type: String,
      default: '1.0'
    },
    checksum: String
  },
  
  // Timestamps
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for better query performance
reportSchema.index({ generatedBy: 1, createdAt: -1 });
reportSchema.index({ type: 1, purpose: 1 });
reportSchema.index({ 'scope.academicYear': 1, 'scope.departments': 1 });
reportSchema.index({ status: 1 });
reportSchema.index({ expiresAt: 1 });

// Virtual for report age
reportSchema.virtual('age').get(function() {
  return Math.floor((Date.now() - this.createdAt) / (1000 * 60 * 60 * 24));
});

// Virtual for download URL
reportSchema.virtual('downloadUrl').get(function() {
  if (this.file && this.file.url) {
    return `/api/reports/${this._id}/download`;
  }
  return null;
});

// Pre-save middleware to update timestamps
reportSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

// Static method to get reports by user
reportSchema.statics.getByUser = function(userId, limit = 10) {
  return this.find({ generatedBy: userId })
    .sort({ createdAt: -1 })
    .limit(limit)
    .populate('generatedBy', 'firstName lastName role');
};

// Static method to get department reports
reportSchema.statics.getDepartmentReports = function(department) {
  return this.find({ 
    'scope.departments': department,
    status: 'completed'
  }).sort({ createdAt: -1 });
};

// Static method to cleanup expired reports
reportSchema.statics.cleanupExpired = function() {
  return this.deleteMany({ 
    expiresAt: { $lt: new Date() },
    status: { $ne: 'generating' }
  });
};

// Instance method to mark as completed
reportSchema.methods.markCompleted = function(fileInfo, statistics) {
  this.status = 'completed';
  this.file = { ...this.file, ...fileInfo };
  this.statistics = { ...this.statistics, ...statistics };
  this.metadata.generationTime = Date.now() - this.createdAt;
  return this.save();
};

// Instance method to mark as failed
reportSchema.methods.markFailed = function(error) {
  this.status = 'failed';
  this.metadata.error = error;
  return this.save();
};

// Instance method to share report
reportSchema.methods.shareWith = function(userId, permissions = 'view') {
  const existingShare = this.sharedWith.find(
    share => share.user.toString() === userId.toString()
  );
  
  if (existingShare) {
    existingShare.permissions = permissions;
    existingShare.sharedAt = new Date();
  } else {
    this.sharedWith.push({
      user: userId,
      permissions,
      sharedAt: new Date()
    });
  }
  
  return this.save();
};

// Instance method to check access
reportSchema.methods.hasAccess = function(userId, requiredPermission = 'view') {
  // Owner has full access
  if (this.generatedBy.toString() === userId.toString()) {
    return true;
  }
  
  // Check if publicly accessible
  if (this.isPublic && requiredPermission === 'view') {
    return true;
  }
  
  // Check shared permissions
  const share = this.sharedWith.find(
    share => share.user.toString() === userId.toString()
  );
  
  if (share) {
    const permissionLevels = ['view', 'download', 'edit'];
    const userLevel = permissionLevels.indexOf(share.permissions);
    const requiredLevel = permissionLevels.indexOf(requiredPermission);
    return userLevel >= requiredLevel;
  }
  
  return false;
};

module.exports = mongoose.model('Report', reportSchema);
